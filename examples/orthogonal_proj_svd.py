"""
This script trains a DACTBAE model on a point cloud generated from a Riemannian manifold with a specified drift
and diffusion process. The trained autoencoder is then used to fit both a drift and a diffusion model in the latent
space using a latent neural SDE. The script computes and prints various extrapolation losses, including reconstruction,
drift, diffusion, and tangent drift errors, and visualizes the model's performance by plotting the predicted vs. true
paths in the ambient space. Additionally, it compares the SDE paths generated by the model against the true paths.
"""

if __name__ == "__main__":
    import torch
    import numpy as np
    import sympy as sp
    from shillml.utils import process_data
    from shillml.diffgeo import RiemannianManifold
    from shillml.pointclouds import PointCloud
    from shillml.pointclouds.dynamics import SDECoefficients
    # TODO: drop out, batch normalization, skip connections-- try these architectures, try differen tinitial network
    # weights
    # Inputs
    train_seed = 17
    num_points = 100
    # Boundary for point cloud
    a = -3
    b = 3
    epsilon = 1.
    bounds = [(a, b), (a, b)]
    large_bounds = [(a - epsilon, b + epsilon), (a - epsilon, b + epsilon)]
    # Flattening factors
    c1, c2 = 10, 10

    # Define the manifold
    u, v = sp.symbols("u v", real=True)
    local_coordinates = sp.Matrix([u, v])
    # Product
    fuv = u*v/c1

    # Paraboloid
    # fuv = (u/c1)**2+(v/c2)**2

    # # Mixture of Gaussians
    # sigma_2 = 1.
    # fuv = (0.5 * sp.exp(-((u + 0.9) ** 2 + (v + 0.9) ** 2) / (2 * sigma_2)) / (np.sqrt(2 * np.pi * sigma_2)) +
    #        0.5 * sp.exp(-((u - 0.9) ** 2 + (v - 0.9) ** 2) / (2 * sigma_2)) / (np.sqrt(2 * np.pi * sigma_2)))

    # Creating the manifold
    chart = sp.Matrix([u, v, fuv])
    manifold = RiemannianManifold(local_coordinates, chart)
    coefs = SDECoefficients()

    # BM
    # local_drift = sp.Matrix([0, 0])
    # local_diffusion = sp.Matrix([[1, 0], [0, 1]])

    # RBM
    # local_drift = manifold.local_bm_drift()
    # local_diffusion = manifold.local_bm_diffusion()

    # # Langevin with double well potential
    local_drift = manifold.local_bm_drift() - 0.2 * manifold.metric_tensor().inv() * sp.Matrix(
        [4 * u * (u ** 2 - 1), 2 * v])
    local_diffusion = manifold.local_bm_diffusion() * coefs.diffusion_circular()/5

    # Generate the point cloud plus dynamics observations
    cloud = PointCloud(manifold, bounds, local_drift, local_diffusion, compute_orthogonal_proj=True)
    # returns points, weights, drifts, cov, local coord
    x, _, mu, cov, local_x = cloud.generate(num_points, seed=train_seed)
    p_true = cloud.get_true_orthogonal_proj(local_x)
    p_true = torch.tensor(p_true, dtype=torch.float32)
    p_svd_estimate = process_data(x, mu, cov, d=2, return_frame=True)[3]
    print("MSE of SVD-P(x) against True-P(x):")
    print(torch.mean(torch.linalg.matrix_norm(p_svd_estimate-p_true, ord="fro")).item())
